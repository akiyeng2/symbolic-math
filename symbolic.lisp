;;;; Some symbolic algebra in infix notation

;; TODO: rewrite macro and add * & - simplifications for + & -

;;; Set globals
(defconstant e (exp 1) "Euler's Number")  
(defconstant i #C(0 1) "Imaginary Number")
(defun ^ (a b) (expt a b))

(defvar op '((+ 1) (- 1) (* 1) (/ 1) (^ 1) (log 0)
	     (sin 0) (cos 0) (tan 0) (sinh 0) (cosh 0)
	     (tanh 0) (asin 0) (acos 0) (atan 0) (asinh 0)
	     (acosh 0) (atanh 0)))

(defvar delta-table '((sin (cos x)) (cos (0 - (sin x)))
		      (tan (1 / ((cos x) ^ 2)))
		      (sinh (cosh x)) (cosh (sinh x))
		      (tanh (1 / ((cosh x) ^ 2)))
		      (asin (1 / ((1 - (x ^ 2)) ^ 1/2)))
		      (acos (0 - (1 / ((1 - (x ^ 2)) ^ 1/2))))
		      (atan (1 / (1 + (x ^ 2))))
		      (asinh (1 / ((1 + (x ^ 2)) ^ 1/2)))
		      (acosh (1 / (((x - 1) * (x + 1)) ^ 1/2)))
		      (atanh (1 / (1 - (x ^ 2)))) (log (1 / x))))

(defmacro simple-infix (a b operator clauses-one clauses-two &optional (clauses-three nil))
  `(cond ((and (numberp ,a) (numberp ,b))
	  (,operator ,a ,b))
	 ((numberp ,a)
	  (cond ,@clauses-one))
	 ((numberp ,b)
	  (cond ,@clauses-two))
	 (t (cond ,@clauses-three
		  (t `(,a ,',operator ,b))))))

(defun operatorp (operator)
  (dolist (pair op)
    (when (eql operator (first pair))
      (return t))))

(defun varp (symbol)
  (and (not (operatorp symbol)) (symbolp symbol))) 

;;; Simplifying functions
(defun get-var (list)
  (first (member-if #'varp list)))

(defun get-num (list)
  (first (member-if #'numberp list)))

(defun simple-+ (a b)
  (simple-infix a b +
		(((zerop a) b) (t `(,a + ,b)))
		(((zerop b) a) (t `(,a + ,b)))
		(((equal a b) `(,2 * ,a))
		 ((and (listp b) (eql (first b) '-))
		  (simple-- a (second b)))
		 ((and (listp b) (listp a) (member '+ b) (member '+ a))
		  (dolist (k '(0 2)) 
		    (dolist (j '(0 2))
		      (when (eql (type-of (nth k a)) (type-of (nth j b)))
			(return-from simple-+ 
			  (simple-+ (simple-+ (nth k a) (nth j b))
				    (simple-+ (nth (- 2 k) a) (nth (- 2 j) b))))))))
		 ((and (listp b) (listp a) (member '- b) (member '+ a))
		  (dolist (k '(0 2)) 
		    (dolist (j '(0 2))
		      (when (eql (type-of (nth k a)) (type-of (nth j b)))
			(return-from simple-+ 
			  (simple-+ (simple-+ (nth k a) (simple-- 0 (nth j b)))
				    (simple-+ (nth (- 2 k) a) (nth (- 2 j) b))))))))
		 ((and (listp b) (listp a) (member '+ b) (member '- a))
		  (dolist (k '(0 2)) 
		    (dolist (j '(0 2))
		      (when (eql (type-of (nth k a)) (type-of (nth j b)))
			(return-from simple-+ 
			  (simple-+ (simple-+ (nth k a) (simple-- 0 (nth j b)))
				    (simple-+ (nth (- 2 j) b) (nth (- 2 k) a))))))))
		 ((and (listp b) (listp a) (member '- b) (member '- a))
		  (dolist (k '(0 2)) 
		    (dolist (j '(0 2))
		      (when (and (eql (type-of (nth k a)) (type-of (nth j b)))
				 (eq k 0))
			(return-from simple-+ 
			  (simple-- (simple-- (nth k a) (simple-- 0 (nth j b)))
				    (simple-- (nth (- 2 k) a) (simple-- 0 (nth (- 2 j) b))))))
		      (when (and (eql (type-of (nth k a)) (type-of (nth j b)))
				 (eq k 2))
			(return-from simple-+
			  (simple-- (simple-- (nth (- 2 k) a) (simple-- 0 (nth (- 2 j) b)))
				    (simple-- (nth k a) (simple-- 0 (nth j b)))))))))
		 
		 ((and (listp b) (listp a)
		       (member '* b) (member '* a))
		  (dolist (k '(0 2))
		    (dolist (j '(0 2))
		      (when (and (eql (nth k a) (nth j b)) (not (numberp (nth k a))))
			(return-from simple-+ (simple-* (nth k a)
							(simple-+ (nth (- 2 k) a) (nth (- 2 j) b))))))))
		 ((and (listp b) (listp a)
		       (member '+ b) (member '* a))
		  (dolist (k '(0 2))
		    (dolist (j '(0 2))
		      (when (and (eql (nth k a) (nth j b)) (not (numberp (nth k a))))
			(return-from simple-+ 
			  (simple-+ (simple-* (nth k a)
					      (simple-+ (nth (- 2 k) a) 1))
				    (nth (- 2 j) b)))))))
		 ((and (listp b) (listp a)
		       (member '+ a) (member '* b))
		  (dolist (k '(0 2))
		    (dolist (j '(0 2))
		      (when (and (eql (nth k b) (nth j a)) (not (numberp (nth k b))))
			(return-from simple-+ 
			  (simple-+ (simple-* (nth k b)
					      (simple-+ (nth (- 2 k) b) 1))
				    (nth (- 2 j) a)))))))
		 ((and (listp b) (member '* b) (member a b))
		  (if (member-if #'numberp (member '* b))
		      (simple-* a (simple-+ (third b) 1))
		      (simple-* a (simple-+ (first b) 1))))
		 ((and (listp a) (member '* a) (member b a))
		  (if (member-if #'numberp (member '* a))
		      (simple-* b (simple-+ (third a) 1))
		      (simple-* b (simple-+ (first a) 1)))))))

(defun simple-- (a b)
  (simple-infix a b -
		(((zerop a) `(- ,b)) (t `(,a - ,b)))
		(((zerop b) a) (t `(,a - ,b)))
		(((equal a b) 0)
		 ((and (listp b) (eql (first b) '-))
		  (simple-+ a (second b)))
		 ((and (listp b) (listp a) (member '+ b) (member '+ a))
		  (dolist (k '(0 2)) 
		    (dolist (j '(0 2))
		      (when (eql (type-of (nth k a)) (type-of (nth j b)))
			(return-from simple-- 
			  (simple-+ (simple-- (nth k a) (nth j b))
				    (simple-- (nth (- 2 k) a) (nth (- 2 j) b))))))))
		 ((and (listp b) (listp a) (member '- b) (member '+ a))
		  (dolist (k '(0 2)) 
		    (dolist (j '(0 2))
		      (when (eql (type-of (nth k a)) (type-of (nth j b)))
			(return-from simple-- 
			  (simple-+ (simple-- (nth k a) (simple-- 0 (nth j b)))
				    (simple-- (nth (- 2 k) a) (nth (- 2 j) b))))))))
		 ((and (listp b) (listp a) (member '+ b) (member '- a))
		  (dolist (k '(0 2)) 
		    (dolist (j '(0 2))
		      (when (eql (type-of (nth k a)) (type-of (nth j b)))
			(return-from simple-- 
			  (simple-+ (simple-- (simple-- 0 (nth j b)) (nth k a))
				    (simple-- (nth (- 2 k) a) (nth (- 2 j) b))))))))
		 		 ((and (listp b) (listp a) (member '- b) (member '- a))
		  (dolist (k '(0 2)) 
		    (dolist (j '(0 2))
		      (when (and (eql (type-of (nth k a)) (type-of (nth j b)))
				 (eq k 0))
			(return-from simple-- 
			  (simple-- (simple-+ (nth k a) (simple-- 0 (nth j b)))
				    (simple-+ (nth (- 2 k) a) (simple-- 0 (nth (- 2 j) b))))))
		      (when (and (eql (type-of (nth k a)) (type-of (nth j b)))
				 (eq k 2))
			(return-from simple--
			  (simple-- (simple-+ (nth (- 2 k) a) (simple-- 0 (nth (- 2 j) b)))
				    (simple-+ (nth k a) (simple-- 0 (nth j b)))))))))
		 ((and (listp b) (listp a)
		       (member '* b) (member '* a))
		  (dolist (k '(0 2))
		    (dolist (j '(0 2))
		      (when (and (eql (nth k a) (nth j b)) (not (numberp (nth k a))))
			(return-from simple-- (simple-* (nth k a)
							(simple-- (nth (- 2 k) a) (nth (- 2 j) b))))))))
		 ((and (listp b) (listp a)
		       (member '+ b) (member '* a))
		  (dolist (k '(0 2))
		    (dolist (j '(0 2))
		      (when (and (eql (nth k a) (nth j b)) (not (numberp (nth k a))))
			(return-from simple-- 
			  (simple-+ (simple-* (nth k a)
					      (simple-- (nth (- 2 k) a) 1))
				    (nth (- 2 j) b)))))))
		 ((and (listp b) (listp a)
		       (member '+ a) (member '* b))
		  (dolist (k '(0 2))
		    (dolist (j '(0 2))
		      (when (and (eql (nth k b) (nth j a)) (not (numberp (nth k b))))
			(return-from simple-- 
			  (simple-+ (simple-* (nth k b)
					      (simple-- 1 (nth (- 2 k) b) ))
				    (nth (- 2 j) a)))))))
		 ((and (listp b) (member '* b) (member a b))
		  (if (member-if #'numberp (member '* b))
		      (simple-* a (simple-- 1 (third b)))
		      (simple-* a (simple-- 1 (first b)))))
		 ((and (listp a) (member '* a) (member b a))
		  (if (member-if #'numberp (member '* a))
		      (simple-* b (simple-- (third a) 1))
		      (simple-* b (simple-- (first a) 1)))))))

(defun simple-* (a b)
  (simple-infix a b *
		(((zerop a) 0) ((= a 1) b) (t `(,a * ,b)))
		(((zerop b) 0) ((= b 1) a) (t `(,a * ,b)))
		(((equal a b) `(,a ^ ,2))
		 ((and (listp b) (listp a)
		       (member '^ b) (member '^ a)
		       (eql (get-var a) (get-var b)))
		  (simple-^ (get-var a) (+ (get-num a) (get-num b))))
		 ((and (listp b) (member '^ b) (member a b))
		  (if (member-if #'numberp (member '^ b))
		      (simple-^ a (simple-+ (third b) 1))
		      (simple-^ a (simple-+ (first b) 1))))
		 ((and (listp a) (member '^ a) (member b a))
		  (if (member-if #'numberp (member '^ a))
		      (simple-^ b (simple-+ (third a) 1))
		      (simple-^ b (simple-+ (first a) 1)))))))

(defun simple-/ (a b)
  (simple-infix a b /
		(((zerop a) 0) (t `(,a / ,b)))
		((t `(,a / ,b)))))

(defun simple-^ (a b)
  (simple-infix a b ^
		(((zerop a) 0) ((= a 1) 1) (t `(,a ^ ,b)))
		(((zerop b) 1) ((= b 1) a) (t `(,a ^ ,b)))))

(defun simple-prefix (operator a)
  (cond ((numberp a) (funcall operator a))
	(t `(,operator ,a))))

(defun simple (operator a &optional (b nil))
  (cond ((eq operator '+) (simple-+ a b))
	((eq operator '-) (simple-- a b))
	((eq operator '*) (simple-* a b))
	((eq operator '/) (simple-/ a b))
	((eq operator '^) (simple-^ a b))
	(t (simple-prefix operator a))))

(defun simplify (expr)
  (dolist (pair op)
    (when (atom expr) (return expr))
    (when (null (rest expr)) (return (simplify (first expr))))
    (when (eql (first pair) (second expr))
      (return (simple (second expr) (simplify (first expr))
		      (simplify (third expr)))))
    (when (eql (first pair) (first expr))
      (return (simple (first expr) (simplify (second expr)))))))

;;; Derivative helper functions
(defun delta-atom (atom wrt)
  (if (eql atom wrt) 1 0))

(defun delta-operate (operator list wrt)
  (cond
    ((eql operator '+) (delta-+ list wrt))
    ((eql operator '-) (delta-- list wrt))
    ((eql operator '*) (delta-* list wrt))
    ((eql operator '/) (delta-/ list wrt))
    ((eql operator '^) (delta-^ list wrt))
    (t (dolist (pair delta-table)
	 (when (eql operator (first pair))
	   (return (simple-* (delta (second list) wrt)
			     (simplify (second pair)))))))))

(defun delta-+ (list wrt)
  (let ((a (first list)) (b (third list)))
    (simple-+ (delta a wrt) (delta b wrt))))

(defun delta-- (list wrt)
  (let ((a (first list)) (b (third list)))
    (simple-- (delta a wrt) (delta b wrt))))

(defun delta-* (list wrt)
  (let ((a (first list)) (b (third list)))
    (simple-+ (simple-* (delta a wrt) b)
	      (simple-* (delta b wrt) a))))

(defun delta-/ (list wrt)
  (let ((a (first list)) (b (third list)))
    (simple-/ (simple-- (simple-* (delta a wrt) b)
			(simple-* (delta b wrt) a))
	      (simple-^ b 2))))

(defun delta-power (list wrt)
  (let ((a (first list)) (b (third list)))
    (simple-* (delta a wrt)
	      (simple-* b (simple-^ a (simple-- b 1))))))

(defun delta-exp (list wrt)
  (let ((a (first list)) (b (third list)))
    (simple-* (delta b wrt)
	      (simple-* `(log ,a) (simple-^ a b)))))

(defun delta-^ (list wrt)
  (simple-+ (delta-power list wrt)
	    (delta-exp list wrt)))

;;; Derivative taker
(defun delta (expr wrt)
  (cond
    ((atom expr) (delta-atom expr wrt))
    ((null (rest expr)) (delta (first expr) wrt))
    ((eql (first expr) '-) (delta-- `(0 - ,(second expr)) wrt))
    (t (dolist (pair op)
	 (when (eql (first pair) (nth (second pair) expr))
	   (return (delta-operate (first pair) expr wrt)))))))
